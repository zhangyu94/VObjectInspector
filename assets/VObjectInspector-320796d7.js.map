{"version":3,"file":"VObjectInspector-320796d7.js","sources":["../../src/utils/data.ts","../../src/utils/path.ts","../../src/components/VObjectValue.vue","../../src/components/VObjectPreview.vue","../../src/components/VObjectLabel.vue","../../src/components/VObjectRootLabel.vue","../../src/components/VTreeNode.vue","../../src/components/VConnectedTreeNode.vue","../../src/components/VTreeView.vue","../../src/VObjectInspector.vue"],"sourcesContent":["// Safely get the value of a property.\n// Returns undefined if the object does not have the property.\nexport const getPropertyValue = (\n  object: unknown,\n  propertyName: string,\n): unknown => {\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    object,\n    propertyName,\n  )\n  if (propertyDescriptor === undefined) return undefined\n  if (propertyDescriptor.get) {\n    try {\n      return propertyDescriptor.get()\n    }\n    catch {\n      return propertyDescriptor.get\n    }\n  }\n\n  return propertyDescriptor.value\n}\n\nexport type ObjectIterator = (object: unknown) => Generator<{\n  name: unknown\n  data: unknown\n  isNonEnumerable: boolean\n}, void, unknown>\n\n// The type of compare function used by Array.prototype.sort\nexport type CompareFunction = ((a: string, b: string) => number) | undefined\n\n// Create a safe iterator that can iterate on arbitrary\n// JavaScript variable's properties.\nexport const createIterator = (\n  showNonEnumerable: boolean,\n  sortObjectKeys: boolean | CompareFunction,\n): ObjectIterator => {\n  function* objectIterator(data: unknown) {\n    const shouldIterate = (typeof data === 'object' && data !== null)\n      || typeof data === 'function'\n    if (!shouldIterate) return\n\n    const dataIsArray = Array.isArray(data)\n\n    // iterable objects (except arrays)\n    if (!dataIsArray && (data as Iterable<unknown>)[Symbol.iterator]) {\n      let i = 0\n\n      for (const entry of data as Iterable<unknown>) {\n        if (Array.isArray(entry) && entry.length === 2) {\n          const [k, v] = entry\n          yield {\n            name: k,\n            data: v,\n            isNonEnumerable: false,\n          }\n        }\n        else {\n          yield {\n            name: i.toString(),\n            data: entry,\n            isNonEnumerable: false,\n          }\n        }\n        i += 1\n      }\n    }\n    else {\n      const keys = Object.getOwnPropertyNames(data)\n      if (sortObjectKeys === true && !dataIsArray) {\n        // Array keys should not be sorted in alphabetical order\n        keys.sort()\n      }\n      else if (typeof sortObjectKeys === 'function') {\n        keys.sort(sortObjectKeys)\n      }\n\n      for (const propertyName of keys) {\n        if ({}.propertyIsEnumerable.call(data, propertyName)) {\n          const propertyValue = getPropertyValue(data, propertyName)\n          yield {\n            name: propertyName || '\"\"',\n            data: propertyValue,\n            isNonEnumerable: false,\n          }\n        }\n        else if (showNonEnumerable) {\n          // To work around the error\n          // (happens some time when propertyName === 'caller' || propertyName === 'arguments')\n          // 'caller' and 'arguments' are restricted function properties\n          // and cannot be accessed in this context\n          // http://stackoverflow.com/questions/31921189/caller-and-arguments-are-restricted-function-properties-and-cannot-be-access\n          let propertyValue\n          try {\n            propertyValue = getPropertyValue(data, propertyName)\n          }\n          catch (e) {\n            // console.warn(e)\n          }\n\n          if (propertyValue !== undefined) {\n            yield {\n              name: propertyName,\n              data: propertyValue,\n              isNonEnumerable: true,\n            }\n          }\n        }\n      }\n\n      // [[Prototype]] of the object: `Object.getPrototypeOf(data)`\n      // the property name is shown as \"__proto__\"\n      if (showNonEnumerable && data !== Object.prototype /* already added */) {\n        yield {\n          name: '__proto__',\n          data: Object.getPrototypeOf(data),\n          isNonEnumerable: true,\n        }\n      }\n    }\n  }\n\n  return objectIterator\n}\n","import { getPropertyValue } from './data'\nimport type { ObjectIterator } from './data'\n\nexport const DEFAULT_ROOT_PATH = '$'\n\nconst WILDCARD = '*'\n\n/** Checks whether the data has child nodes. */\nexport const hasChildNodes = (\n  data: unknown,\n  dataIterator: ObjectIterator,\n) => (\n  !dataIterator(data).next().done\n)\n\n/**\n * Create a list of wildcard paths\n * used to match all attributes to the given level.\n */\nexport const wildcardPathsFromLevel = (level: number): string[] => (\n  // i is depth\n  Array.from({ length: level }, (_, i) => (\n    [DEFAULT_ROOT_PATH]\n      .concat(Array.from({ length: i }, () => '*'))\n      .join('.')\n  ))\n)\n\n/**\n * Get the paths that should be expanded.\n * In the returned object, if a path should be expanded,\n * it will be stored as key with value storing true.\n */\nexport const getExpandedPaths = (\n  data: unknown,\n  dataIterator: ObjectIterator,\n  expandPaths: string[],\n  expandLevel: number,\n  prevExpandedPaths: Record<string, boolean>,\n): Record<string, boolean> => {\n  const wildcardPaths: string[] = wildcardPathsFromLevel(expandLevel)\n    .concat(expandPaths)\n    .filter((path) => typeof path === 'string') // could be undefined\n\n  const expandedPaths: string[] = []\n  wildcardPaths.forEach((wildcardPath) => {\n    const keyPaths: string[] = wildcardPath.split('.')\n    const populatePaths = (curData: unknown, curPath: string, depth: number) => {\n      if (depth === keyPaths.length) {\n        expandedPaths.push(curPath)\n        return\n      }\n      const key = keyPaths[depth]\n      if (depth === 0) {\n        if (\n          hasChildNodes(curData, dataIterator)\n          && (key === DEFAULT_ROOT_PATH || key === WILDCARD)\n        ) {\n          populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1)\n        }\n      }\n      else if (key === WILDCARD) {\n        for (const item of dataIterator(curData)) {\n          if (hasChildNodes(item.data, dataIterator)) {\n            populatePaths(item.data, `${curPath}.${item.name}`, depth + 1)\n          }\n        }\n      }\n      else {\n        const value = getPropertyValue(curData, key)\n        if (hasChildNodes(value, dataIterator)) {\n          populatePaths(value, `${curPath}.${key}`, depth + 1)\n        }\n      }\n    }\n\n    populatePaths(data, '', 0)\n  })\n\n  const obj = { ...prevExpandedPaths }\n  expandedPaths.forEach((d) => {\n    obj[d] = true\n  })\n  return obj\n}\n","<script setup lang=\"ts\">\nimport { computed, inject, ref } from 'vue'\n\ninterface ObjectInfo {\n  class: string\n  title: string\n}\n\nconst { object } = defineProps({\n  /** The JavaScript variable (of any type) to inspect. */\n  object: {\n    type: null,\n    required: true,\n  },\n})\n\nconst getInfo = (object: unknown): ObjectInfo => {\n  const type = typeof object\n  if (type === 'bigint') {\n    return {\n      class: 'object-value-number',\n      title: `${object}n`,\n    }\n  }\n  if (type === 'number') {\n    return {\n      class: 'object-value-number',\n      title: `${object}`,\n    }\n  }\n  if (type === 'string') {\n    return {\n      class: 'object-value-string',\n      title: `\"${object}\"`,\n    }\n  }\n  if (type === 'boolean') {\n    return {\n      class: 'object-value-boolean',\n      title: `${object}`,\n    }\n  }\n  if (type === 'undefined') {\n    return {\n      class: 'object-value-undefined',\n      title: 'undefined',\n    }\n  }\n  if (type === 'object') {\n    if (object === null) {\n      return {\n        class: 'object-value-null',\n        title: 'null',\n      }\n    }\n    if (object instanceof Date) {\n      return {\n        class: '',\n        title: object.toString(),\n      }\n    }\n    if (object instanceof RegExp) {\n      return {\n        class: 'object-value-regexp',\n        title: object.toString(),\n      }\n    }\n    if (Array.isArray(object)) {\n      return {\n        class: '',\n        title: `Array(${object.length})`,\n      }\n    }\n    if (!(object as object).constructor) {\n      return {\n        class: '',\n        title: 'Object',\n      }\n    }\n    return {\n      class: '',\n      title: (object as object).constructor.name,\n    }\n  }\n  if (type === 'function') {\n    return {\n      class: '',\n      title: '',\n    }\n  }\n  if (type === 'symbol') {\n    return {\n      class: 'object-value-symbol',\n      title: (object as symbol).toString(),\n    }\n  }\n  return {\n    class: '',\n    title: '',\n  }\n}\n\nconst type = computed(() => typeof object)\nconst info = computed(() => getInfo(object))\n\n// `provide` from top component `VObjectInspector`\nconst darkTheme = inject('darkTheme', ref(false))\nconst style = computed(() => ({\n  nullishColor: 'rgb(127, 127, 127)',\n  stringColor: darkTheme.value ? 'rgb(233, 63, 59)' : 'rgb(196, 26, 22)',\n  numeralColor: darkTheme.value ? 'hsl(252, 100%, 75%)' : 'rgb(28, 0, 207)',\n  functionPrefixColor: darkTheme.value ? 'rgb(85, 106, 242)' : 'rgb(170, 13, 145)',\n}))\n</script>\n\n<template>\n  <span\n    :class=\"info.class\"\n    :title=\"info.title\"\n  >\n    <span>{{ info.title }}</span>\n    <template v-if=\"type === 'function'\">\n      <span class=\"object-value-function-prefix\">Æ’&nbsp;</span>\n      <span class=\"object-value-function-name\">{{ object.name }}()</span>\n    </template>\n  </span>\n</template>\n\n<style scoped>\n.object-value-null {\n  color: v-bind('style.nullishColor');\n}\n.object-value-undefined {\n  color: v-bind('style.nullishColor');\n}\n.object-value-regexp {\n  color: v-bind('style.stringColor');\n}\n.object-value-string {\n  color: v-bind('style.stringColor');\n}\n.object-value-symbol {\n  color: v-bind('style.stringColor');\n}\n.object-value-number {\n  color: v-bind('style.numeralColor');\n}\n.object-value-boolean {\n  color: v-bind('style.numeralColor');\n}\n.object-value-function-prefix {\n  color: v-bind('style.functionPrefixColor');\n  font-style: italic;\n}\n.object-value-function-name {\n  font-style: italic;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, inject, ref, toRefs } from 'vue'\nimport VObjectValue from './VObjectValue.vue'\n\nconst props = defineProps({\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n})\nconst { data } = toRefs(props)\n\nconst isSimpleType = (object: unknown): boolean => (\n  typeof object !== 'object'\n    || object === null\n    || object instanceof Date\n    || object instanceof RegExp\n)\n\n// `provide` from top component `VObjectInspector`\nconst objectMaxProperties = inject('objectMaxProperties', ref(5))\nconst arrayMaxProperties = inject('arrayMaxProperties', ref(10))\n\nconst object = computed((): unknown => data.value)\nconst isSimple = computed((): boolean => isSimpleType(object.value))\n\n/** The name of object constructor. */\nconst className = computed((): string => {\n  if (typeof object.value !== 'object' || object.value === null) return ''\n  const { constructor } = object.value\n  const constructorName = constructor ? constructor.name : 'Object'\n  return constructorName === 'Object' ? '' : `${constructorName} `\n})\n\n/**\n * A slice of the object (which is an array) for preview.\n * If the object is not array, returns empty array.\n */\nconst previewArray = computed((): unknown[] => {\n  if (!Array.isArray(object.value)) return []\n  return object.value.slice(0, arrayMaxProperties.value)\n})\n\n/**\n * A slice of the object (which is an object) for preview.\n * If the object is not object, returns empty object.\n */\nconst previewObjectItems = computed((): Record<string, unknown>[] => {\n  if (typeof object.value !== 'object' || object.value === null) return []\n  let keys = Object.keys(object.value)\n  if (keys.length > objectMaxProperties.value) {\n    keys = keys.slice(0, objectMaxProperties.value)\n  }\n  return keys.map((k) => ({\n    key: k,\n    val: (object.value as Record<string, unknown>)[k],\n  }))\n})\n</script>\n\n<template>\n  <span>\n    <VObjectValue\n      v-if=\"isSimple\"\n      :object=\"object\"\n    />\n    <span v-else-if=\"Array.isArray(object)\">\n      <span\n        class=\"object-preview-desc\"\n      >{{ object.length === 0 ? '' : `(${object.length})\\xa0` }}</span>\n      <span class=\"object-preview\">\n        <span>[</span>\n        <span\n          v-for=\"(item, index) of previewArray\"\n          :key=\"index\"\n        >\n          <span v-if=\"index !== 0\">, </span>\n          <VObjectValue :object=\"item\" />\n          <span v-if=\"index === arrayMaxProperties - 1\">, </span>\n          <span v-if=\"index === arrayMaxProperties - 1\">â€¦</span>\n        </span>\n        <span>]</span>\n      </span>\n    </span>\n    <span v-else>\n      <span class=\"object-preview-desc\">{{ className }}</span>\n      <span class=\"object-preview\">\n        <span>{</span>\n        <span\n          v-for=\"(item, index) of previewObjectItems\"\n          :key=\"index\"\n        >\n          <span v-if=\"index !== 0\">, </span>\n          <span class=\"object-name-preview\">{{ item.key || '\"\"' }}</span>:\n          <VObjectValue :object=\"item.val\" />\n          <span v-if=\"index === objectMaxProperties - 1\">â€¦</span>\n        </span>\n        <span>}</span>\n      </span>\n    </span>\n  </span>\n</template>\n\n<style scoped>\n.object-preview {\n  font-style: italic;\n}\n\n.object-name-preview {\n  color: rgb(95, 99, 104);\n}\n\n.object-preview-desc {\n  font-style: italic;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, inject, ref } from 'vue'\nimport type { PropType } from 'vue'\nimport VObjectPreview from './VObjectPreview.vue'\nimport VObjectValue from './VObjectValue.vue'\n\nconst { data, name, isNonEnumerable } = defineProps({\n/** The JavaScript variable to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The variable name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n  /** Whether the variable is non-enumerable. */\n  isNonEnumerable: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n})\n\n// `provide` from top component `VObjectInspector`\nconst darkTheme = inject('darkTheme', ref(false))\nconst style = computed(() => ({\n  nameColor: darkTheme.value ? 'rgb(227, 110, 236)' : 'rgb(136, 19, 145)',\n}))\n</script>\n\n<template>\n  <span :title=\"name\">\n    <span\n      v-if=\"typeof name === 'string'\"\n      class=\"object-name\"\n      :class=\"{ 'object-name-dimmed': isNonEnumerable }\"\n    >{{ name }}</span>\n    <VObjectPreview\n      v-else\n      :data=\"name\"\n    />\n    <span>: </span>\n    <VObjectValue :object=\"data\" />\n  </span>\n</template>\n\n<style scoped>\n.object-name {\n  color: v-bind('style.nameColor');\n}\n\n.object-name-dimmed {\n  opacity: 0.6;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, inject, ref } from 'vue'\nimport type { PropType } from 'vue'\nimport VObjectPreview from './VObjectPreview.vue'\n\nconst { data, name } = defineProps({\n  /** The JavaScript variable to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The variable name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n})\n\n// `provide` from top component `VObjectInspector`\nconst darkTheme = inject('darkTheme', ref(false))\nconst style = computed(() => ({\n  nameColor: darkTheme.value ? 'rgb(227, 110, 236)' : 'rgb(136, 19, 145)',\n}))\n</script>\n\n<template>\n  <span>\n    <span v-if=\"typeof name === 'string'\">\n      <span class=\"object-name\">{{ name }}</span>\n      <span>: </span>\n      <VObjectPreview :data=\"data\" />\n    </span>\n    <VObjectPreview\n      v-else\n      :data=\"data\"\n    />\n  </span>\n</template>\n\n<style scoped>\n.object-name {\n  color: v-bind('style.nameColor');\n}\n</style>\n","<script setup lang=\"ts\">\nimport { inject } from 'vue'\nimport type { PropType } from 'vue'\nimport VObjectLabel from './VObjectLabel.vue'\nimport VObjectRootLabel from './VObjectRootLabel.vue'\n\nconst {\n  data,\n  name,\n  depth,\n  isNonEnumerable,\n  expanded,\n  showArrow,\n  showPlaceholder,\n} = defineProps({\n  /** The JavaScript variable to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The variable name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n  /**\n   * The depth of the variable.\n   * (Root variable has depth 0)\n   */\n  depth: {\n    type: Number as PropType<number>,\n    required: true,\n  },\n  /** Whether the variable is non-enumerable. */\n  isNonEnumerable: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n  /** Whether the variable should be expanded. */\n  expanded: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n  /** Whether to show an arrow for expand interaction. */\n  showArrow: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n  /**\n   * Whether to pad a placeholder on the left.\n   * The placeholder makes variable attributes look indented.\n   */\n  showPlaceholder: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n})\n\ndefineEmits<{\n  (e: 'update:expand'): void\n}>()\n\n// `provide` from top component `VObjectInspector`\nconst darkTheme: boolean = inject('darkTheme', false)\n</script>\n\n<template>\n  <li\n    role=\"treeitem\"\n    class=\"tree-node\"\n    :aria-expanded=\"expanded\"\n    :style=\"{\n      color: darkTheme ? '#d5d5d5' : '#000',\n      backgroundColor: darkTheme ? '#242424' : '#fff',\n    }\"\n  >\n    <div\n      class=\"tree-node-preview-container\"\n      @click=\"$emit('update:expand')\"\n    >\n      <span\n        v-if=\"showArrow\"\n        class=\"tree-node-arrow\"\n        :class=\"[\n          expanded ? 'tree-node-arrow-expanded' : 'tree-node-arrow-collapsed',\n        ]\"\n        :style=\"{ color: darkTheme ? '#919191' : '#6e6e6e' }\"\n      >\n        â–¶\n      </span>\n      <!-- Pad a placeholder to make variable attributes indented. -->\n      <span\n        v-else-if=\"showPlaceholder && $slots.default\"\n        class=\"tree-node-placeholder\"\n      >&nbsp;</span>\n      <VObjectRootLabel\n        v-if=\"depth === 0\"\n        :name=\"name\"\n        :data=\"data\"\n      />\n      <VObjectLabel\n        v-else\n        :name=\"name\"\n        :data=\"data\"\n        :is-non-enumerable=\"isNonEnumerable\"\n      />\n    </div>\n\n    <ol\n      role=\"group\"\n      class=\"tree-node-child-nodes-container\"\n    >\n      <!-- The slot to accommodate child nodes. -->\n      <slot v-if=\"expanded\" />\n    </ol>\n  </li>\n</template>\n\n<style scoped>\n.tree-node {\n  line-height: 1.2;\n  cursor: default;\n  box-sizing: border-box;\n  list-style: none;\n  font-family: Menlo, monospace;\n  font-size: 11px;\n}\n\n.tree-node-preview-container {\n  padding-left: 0.125rem;\n  padding-right: 0.125rem;\n}\n\n.tree-node-placeholder {\n  white-space: pre;\n  font-size: 12px;\n  margin-right: 3px;\n}\n\n.tree-node-arrow {\n  display: inline-block;\n  font-size: 12px;\n  margin-right: 3px;\n}\n\n.tree-node-arrow-expanded {\n  transform: rotate(90deg);\n}\n\n.tree-node-arrow-collapsed {\n  transform: rotate(0deg);\n}\n\n.tree-node-child-nodes-container {\n  margin: 0;\n  padding-left: 12px;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, toRefs } from 'vue'\nimport type { PropType } from 'vue'\nimport { hasChildNodes } from '../utils/path'\nimport type { ObjectIterator } from '../utils/data'\nimport VTreeNode from './VTreeNode.vue'\n\nconst props = defineProps({\n  /** The JavaScript variable to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The variable name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n  /** A factory of object property iterators. */\n  dataIterator: {\n    type: Function as PropType<ObjectIterator>,\n    required: true,\n  },\n  /**\n   * The path of the variable.\n   * (Root variable has path DEFAULT_ROOT_PATH)\n   */\n  path: {\n    type: String as PropType<string>,\n    required: true,\n  },\n  /**\n   * The depth of the variable.\n   * (Root variable has depth 0)\n   */\n  depth: {\n    type: Number as PropType<number>,\n    required: true,\n  },\n  /** Whether the variable is non-enumerable. */\n  isNonEnumerable: {\n    type: Boolean as PropType<boolean>,\n    required: true,\n  },\n  /** The list of paths currently expanded. */\n  expandedPaths: {\n    type: Object as PropType<Record<string, boolean>>,\n    required: true,\n  },\n})\n\nconst emit = defineEmits<{\n  (e: 'update:expanded-paths', d: { path: string; val: boolean }): void\n}>()\n\nconst {\n  data,\n  name,\n  dataIterator,\n  path,\n  depth,\n  isNonEnumerable,\n  expandedPaths,\n} = toRefs(props)\n\n/** Whether the variable has child nodes. */\nconst nodeHasChildNodes = computed((): boolean => (\n  hasChildNodes(data.value, dataIterator.value)\n))\n\n/** Whether the variable should be expanded. */\nconst expanded = computed((): boolean => (\n  !!expandedPaths.value[path.value]\n))\n\n/** The variable's child nodes. */\nconst children = computed((): {\n  name: unknown\n  data: unknown\n  isNonEnumerable: boolean\n}[] => (\n  [...dataIterator.value(data.value)]\n))\n\nconst onToggleExpand = (): void => {\n  if (!nodeHasChildNodes.value) return\n  emit('update:expanded-paths', {\n    path: path.value,\n    val: !expanded.value,\n  })\n}\n</script>\n\n<template>\n  <VTreeNode\n    :name=\"name\"\n    :data=\"data\"\n    :depth=\"depth\"\n    :is-non-enumerable=\"isNonEnumerable\"\n    :expanded=\"expanded\"\n    :show-arrow=\"nodeHasChildNodes\"\n    :show-placeholder=\"depth > 0\"\n    @update:expand=\"onToggleExpand\"\n  >\n    <span v-if=\"expanded\">\n      <VConnectedTreeNode\n        v-for=\"(child, i) of children\"\n        :key=\"i\"\n        :data=\"child.data\"\n        :name=\"`${child.name}`\"\n        :data-iterator=\"dataIterator\"\n        :path=\"`${path}.${child.name}`\"\n        :depth=\"depth + 1\"\n        :is-non-enumerable=\"child.isNonEnumerable\"\n        :expanded-paths=\"expandedPaths\"\n        @update:expanded-paths=\"$emit('update:expanded-paths', $event)\"\n      />\n    </span>\n    <span v-else>null</span>\n  </VTreeNode>\n</template>\n","<script setup lang=\"ts\">\nimport { onBeforeMount, ref, toRefs, watch } from 'vue'\nimport type { PropType } from 'vue'\nimport { DEFAULT_ROOT_PATH, getExpandedPaths } from '../utils/path'\nimport type { CompareFunction, ObjectIterator } from '../utils/data'\nimport VConnectedTreeNode from './VConnectedTreeNode.vue'\n\nconst props = defineProps({\n  /** The JavaScript object to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The root variables prefix name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n  /** The depth level to which the tree should be initially expanded. */\n  expandLevel: {\n    type: Number as PropType<number>,\n    default: 0,\n  },\n  /** The list of paths that should be initially expanded. */\n  expandPaths: {\n    type: Array as PropType<string[]>,\n    default: null,\n  },\n  /** A factory of object property iterators. */\n  dataIterator: {\n    type: Function as PropType<ObjectIterator>,\n    required: true,\n  },\n  /**\n   * Whether to sort the object keys.\n   * If true, sort keys in alphabetical order except for arrays.\n   * If false, no sorting is applied\n   * (the keys are ordered by Object.getOwnPropertyNames).\n   * If a compare function is passed,\n   * the keys are sorted by the compare function.\n   */\n  sortObjectKeys: {\n    type: [Boolean, Function] as PropType<boolean | CompareFunction>,\n    default: false,\n  },\n})\n\nconst { data, name, expandLevel, expandPaths, dataIterator } = toRefs(props)\n\n// The list of paths currently expanded.\nconst expandedPaths = ref({})\n\n/** Update expanded paths by the expandPaths parameters. */\nconst updateByExpandPaths = (): string[] => {\n  const paths: string[] = []\n  if (expandPaths.value !== null) {\n    expandPaths.value.forEach((path: string) => {\n      const arr = path.split('.')\n      arr.forEach((_, index) => {\n        paths.push(arr.slice(0, index + 1).join('.'))\n      })\n    })\n  }\n  expandedPaths.value = getExpandedPaths(\n    data.value,\n    dataIterator.value,\n    paths,\n    0,\n    {},\n  )\n  return paths\n}\n\n/** Update expanded paths by the expandLevel parameters. */\nconst updateByExpandLevel = (paths: string[]): void => {\n  expandedPaths.value = getExpandedPaths(\n    data.value,\n    dataIterator.value,\n    paths,\n    expandLevel.value,\n    {},\n  )\n}\n\n/** Update expanded paths by the expandPaths and expandLevel parameters. */\nconst updateExpandedPaths = (): void => {\n  const paths = updateByExpandPaths()\n  updateByExpandLevel(paths)\n}\n\n/** When user interaction triggers update of expanded paths. */\nconst onUpdateExpandedPaths = (\n  { path, val }: { path: string; val: boolean },\n): void => {\n  expandedPaths.value = {\n    ...expandedPaths.value,\n    [path]: val,\n  }\n}\n\nwatch(expandLevel, () => updateByExpandLevel([]))\nwatch(expandPaths, () => updateByExpandPaths())\nonBeforeMount(() => updateExpandedPaths())\n</script>\n\n<template>\n  <ol\n    role=\"tree\"\n    class=\"tree-view-outline\"\n  >\n    <VConnectedTreeNode\n      :data=\"data\"\n      :name=\"name\"\n      :data-iterator=\"dataIterator\"\n      :path=\"DEFAULT_ROOT_PATH\"\n      :depth=\"0\"\n      :is-non-enumerable=\"false\"\n      :expanded-paths=\"expandedPaths\"\n      @update:expanded-paths=\"onUpdateExpandedPaths\"\n    />\n  </ol>\n</template>\n\n<style scoped>\n.tree-view-outline {\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed, provide, toRefs } from 'vue'\nimport type { PropType } from 'vue'\nimport { createIterator } from './utils/data'\nimport type { CompareFunction, ObjectIterator } from './utils/data'\nimport VTreeView from './components/VTreeView.vue'\n\nconst props = defineProps({\n  /** The JavaScript object to inspect. */\n  data: {\n    // Any type.\n    type: null,\n    required: true,\n  },\n  /** The root node's prefix name. */\n  name: {\n    type: String as PropType<string>,\n    default: null,\n  },\n  /** The depth level to which the tree should be initially expanded. */\n  expandLevel: {\n    type: Number as PropType<number>,\n    default: 0,\n  },\n  /** The paths in the tree that should be initially expanded. */\n  expandPaths: {\n    type: Array as PropType<string[]>,\n    default: null,\n  },\n  /** Whether to show non-enumerable properties (e.g., __proto__, length). */\n  showNonEnumerable: {\n    type: Boolean as PropType<boolean>,\n    default: false,\n  },\n  /**\n   * Whether to sort object keys.\n   * If true, sort keys in alphabetical order except for arrays.\n   * If false, no sorting is applied\n   * (the keys are ordered by Object.getOwnPropertyNames).\n   * If a compare function is passed,\n   * the keys are sorted by the compare function.\n   */\n  sortObjectKeys: {\n    type: [Boolean, Function] as PropType<boolean | CompareFunction>,\n    default: false,\n  },\n  /**\n   * The maximal number of object properties to show in preview.\n   * (The ones not in preview are abbreviated with ...)\n   */\n  objectMaxProperties: {\n    type: Number as PropType<number>,\n    default: 5,\n  },\n  /**\n   * The maximal number of array properties to show in preview.\n   * (The ones not in preview are abbreviated with ...)\n   */\n  arrayMaxProperties: {\n    type: Number as PropType<number>,\n    default: 10,\n  },\n  /** Whether to use the dark theme or the light theme. */\n  darkTheme: {\n    type: Boolean as PropType<boolean>,\n    default: false,\n  },\n})\n\nconst {\n  data,\n  name,\n  expandLevel,\n  expandPaths,\n  showNonEnumerable,\n  sortObjectKeys,\n  objectMaxProperties,\n  arrayMaxProperties,\n  darkTheme,\n} = toRefs(props)\n\nprovide('objectMaxProperties', objectMaxProperties)\nprovide('arrayMaxProperties', arrayMaxProperties)\nprovide('darkTheme', darkTheme)\n\n/** A factory of object property iterators. */\nconst dataIterator = computed((): ObjectIterator => (\n  createIterator(showNonEnumerable.value, sortObjectKeys.value)\n))\n</script>\n\n<template>\n  <div\n    class=\"vue-object-inspector\"\n    :class=\"[\n      darkTheme ? 'vue-object-inspector-chromedark' : '',\n    ]\"\n    style=\"overflow-wrap: anywhere; line-break: anywhere;\"\n  >\n    <VTreeView\n      v-bind=\"$attrs\"\n      :data=\"data\"\n      :name=\"name\"\n      :expand-level=\"expandLevel\"\n      :expand-paths=\"expandPaths\"\n      :data-iterator=\"dataIterator\"\n      :sort-object-keys=\"sortObjectKeys\"\n    />\n  </div>\n</template>\n"],"names":["getPropertyValue","object","propertyName","propertyDescriptor","createIterator","showNonEnumerable","sortObjectKeys","objectIterator","data","dataIsArray","i","entry","k","v","keys","propertyValue","DEFAULT_ROOT_PATH","WILDCARD","hasChildNodes","dataIterator","wildcardPathsFromLevel","level","_","getExpandedPaths","expandPaths","expandLevel","prevExpandedPaths","wildcardPaths","path","expandedPaths","wildcardPath","keyPaths","populatePaths","curData","curPath","depth","key","item","value","obj","d","__props","getInfo","type","computed","info","darkTheme","inject","ref","style","props","toRefs","isSimpleType","objectMaxProperties","arrayMaxProperties","isSimple","className","constructor","constructorName","previewArray","previewObjectItems","emit","__emit","name","isNonEnumerable","nodeHasChildNodes","expanded","children","onToggleExpand","updateByExpandPaths","paths","arr","index","updateByExpandLevel","updateExpandedPaths","onUpdateExpandedPaths","val","watch","onBeforeMount","provide"],"mappings":"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"}